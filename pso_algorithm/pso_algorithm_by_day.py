import numpy as np
import pandas as pd
from tabulate import tabulate
import sys
sys.path.append("../rest_server")
from electronic_database_by_day import return_electronic_data_by_day
from weather_database_by_day import return_weather_data_by_day

# 설정 초기 상수
C_bat = 20   # Capacity(kWh)
# C_bat = 20 * 1000   # Capacity(kWh)
SOC_ini = 30        # initial SOC of battery
SOC_min = 10        # minimum SOC of battery
SOC_max = 90        # maximum SOC of battery

Ef_bc = 0.9         # efficiency of battery in charge mode
Ef_bd = 0.85        # efficiency of battery in discharge mode
r_sd = 0.002        # self - discharge rate of battery

P_dgr = 10
# P_dgr = 10 * 1000
Ef_dg = 0.95

def Optimal_PSO_Algorithm(Ef_inv, Con_LOLP, Con_dummy, prompt3, input_p_wind, input_p_pv, input_p_load):

    prompt1_result = []
    prompt2_result = []
    dummy_result = []
    LOLP_result = []
    P_dg_result = []
    state_result = []

    # noinspection PyTypeChecke
    for prompt2 in np.arange(1, 31, 0.05):
        for prompt1 in np.arange(1, 31, 0.05):

            # Types of Power Pattern generated by Wind Turbine during a one day
            u = input_p_wind

            Pw_wind = [0] * 24

            uc = 3   # 최소 발전가능한 풍속 제한 [m/s]
            uf = 25  # 최대 발전가능한 풍속 제한 [m/s]
            ur = 12  # 정격 풍속 [m/s]

            for t in range(24):
                if (u[t] < uc) or (u[t] > uf):
                    Pw_wind[t] = 0  # WT 출력 [MW]
                else:
                    if uc <= u[t] <= ur:
                        Pw_wind[t] = round((u[t] * u[t] - uc * uc) / (ur * ur - uc * uc), 4)  # WT 출력 [MW]
                    else:
                        if ur <= u[t] <= uf:
                            Pw_wind[t] = 1  # WT 출력 [MW]
                            # print(Pw_wind)

            P_wind = Pw_wind

            # Types of Power Pattern generated by Photovoltaic during a one day
            P_pv = input_p_pv

            # Types of Load Pattern during a one day
            P_load = input_p_load

            # Choice a pattern of wind turbine, Photovoltaic and Load
            P_wind = [round(prompt1 * value, 4) for idx, value in enumerate(P_wind)]
            P_pv = [round(prompt2 * value, 4) for idx, value in enumerate(P_pv)]
            P_load = [round(prompt3 * value, 4) for idx, value in enumerate(P_load)]

            # P_wind = [round(prompt1 * 1000 * value, 3) for idx, value in enumerate(P_wind)]
            # P_pv = [round(prompt2 * 1000 * value, 3) for idx, value in enumerate(P_pv)]
            # P_load = [round(prompt3 * value, 3) for idx, value in enumerate(P_load)]

            DAE = sum(P_load)

            # Enter battery data, initial SOC(%), SOC_min(%), SOC_max(%), P_bc(kW), P_bd(kW)
            P_bc = [0] * 24  # output of battery in charge mode
            P_bd = [0] * 24  # output of battery in discharge mode

            # Enter dummy load capacity(kW)
            P_dummy = [0] * 24
            E_dummy = 0

            # Enter diesel generator capacity(kW), output(kW) and efficiency
            P_dg = [0] * 24

            # NPSP algorithm
            t = 1  # initial time
            LOLP = [0] * 24  # initial LOLP at each time
            LOLP_sum = 0
            E_bat = (C_bat * SOC_ini) / 100  # initial kWh capacity of battery at each time
            SOC = [0] * 24  # initial SOC of battery at each time

            # iteration for day calculation(24h)
            for t in range(24):

                SOC[t] = E_bat / C_bat * 100  # SOC calculation of battery at each time

                if P_wind[t] > P_load[t]:  # occurred surplus energy in HRES system
                    if SOC[t] < SOC_max:  # check SOC of battery whether the SOC has enough
                        P_bc[t] = (P_wind[t] - P_load[t] * Ef_inv + P_pv[t]) * Ef_bc  # calculate charge capacity of battery
                        E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc  # accumulate capacity of battery
                    else:
                        P_bc[t] = 0  # calculate charge capacity of battery
                        P_dummy[t] = (P_wind[t] - P_load[t]) + P_pv[t] * Ef_inv  # calculate capacity of dummy loads to cover surplus energy in HRES system
                        E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

                if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) > P_load[t]:  # occurred surplus energy in HRES system
                    if SOC[t] < SOC_max:  # check SOC of battery whether the SOC has enough
                        P_bc[t] = (P_wind[t] + P_pv[t] * Ef_inv - P_load[t]) * Ef_bc * Ef_inv  # calculate charge capacity of battery
                        E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc  # accumulate capacity of battery
                    else:
                        P_bc[t] = 0  # calculate charge capacity of battery
                        P_dummy[t] = P_wind[t] + P_pv[t] * Ef_inv - P_load[t]  # calculate capacity of dummy loads to cover surplus energy in HRES system
                        E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

                if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) <= P_load[t]:  # occurred deficit energy in HRES system
                    if SOC[t] > SOC_min:  # check SOC of battery whether the SOC has lack of capacity
                        P_bd[t] = (P_pv[t] - (P_load[t] - P_wind[t]) / Ef_inv) * Ef_bd  # calculate discharge capacity of battery
                        E_bat = E_bat * (1 - r_sd) - abs(P_bd[t]) * Ef_bd  # accumulate capacity of battery
                    else:
                        P_bd[t] = 0  # calculate charge capacity of battery
                        P_dg[t] = (P_load[t] - P_wind[t] - P_pv[t] * Ef_inv) / Ef_dg  # calculate capacity of diesel generator to cover deficit energy in HRES system
                        if P_dg[t] > P_dgr:  # check the capacity of diesel generator whether it exceeds rated capacity of diesel generator
                            LOLP[t] = 1  # evaluate LOLP at time t
                            LOLP_sum = LOLP_sum + LOLP[t]  # accumulate LOLP at each time
                        else:
                            LOLP[t] = 0  # evaluate LOLP at time t

            # check capacity of HRES with constraints of LOLP and dummy loads
            if E_dummy <= 0:
                state = 'Increasing'
                pass
               #print('Need to increasing capacity of PV or WT.\n')
            else:
                if E_dummy > Con_dummy*DAE:
                    state = 'Decreasing'
                    pass
                    #print('Need to decreasing capacity of PV or WT.\n')
                else:
                    if LOLP_sum / t > Con_LOLP:
                        state = 'Increasing'
                        pass
                        #print('Need to increasing capacity of PV or WT.\n')
                    else:
                        state = '***** Optimal *****'
                        # print('Present capacities of PV and WT are optimal.\n')

            dummy_sum = sum(P_dummy)
            LOLP_sum = sum(LOLP)
            P_dg_sum = sum(P_dg)

            state_result.append(state)
            prompt1_result.append(prompt1)
            prompt2_result.append(prompt2)
            dummy_result.append(dummy_sum)
            LOLP_result.append(LOLP_sum)
            P_dg_result.append(P_dg_sum)

    return prompt1_result, prompt2_result, state_result, dummy_result, LOLP_result, P_dg_result, DAE

def PSO_Algorithm(Ef_inv, Con_LOLP, Con_dummy, prompt1, prompt2, prompt3, input_p_wind, input_p_pv, input_p_load):

    # Types of Power Pattern generated by Wind Turbine during a one day
    u = input_p_wind

    Pw_wind = [0] * 24

    uc = 3   # 최소 발전가능한 풍속 제한 [m/s]
    uf = 25  # 최대 발전가능한 풍속 제한 [m/s]
    ur = 12  # 정격 풍속 [m/s]

    for t in range(24):
        if (u[t] < uc) or (u[t] > uf):
            Pw_wind[t] = 0  # WT 출력 [MW]
        else:
            if uc <= u[t] <= ur:
                Pw_wind[t] = round((u[t] * u[t] - uc * uc) / (ur * ur - uc * uc), 4)  # WT 출력 [MW]
            else:
                if ur <= u[t] <= uf:
                    Pw_wind[t] = 1  # WT 출력 [MW]
                    # print(Pw_wind)

    P_wind = Pw_wind

    # Types of Power Pattern generated by Photovoltaic during a one day(5~25)
    P_pv = input_p_pv

    # Types of Load Pattern during a one day(5~9)
    P_load = input_p_load

    # Choice a pattern of wind turbine, Photovoltaic and Load
    P_wind = [round(prompt1 * value, 4) for idx, value in enumerate(P_wind)]
    P_pv = [round(prompt2 * value, 4) for idx, value in enumerate(P_pv)]
    P_load = [round(prompt3 * value, 4) for idx, value in enumerate(P_load)]

    # P_wind = [round(prompt1 * 1000 * value, 3) for idx, value in enumerate(P_wind)]
    # P_pv = [round(prompt2 * 1000 * value, 3) for idx, value in enumerate(P_pv)]
    # P_load = [round(prompt3 * value, 3) for idx, value in enumerate(P_load)]

    DAE = sum(P_load)

    # Enter battery data, initial SOC(%), SOC_min(%), SOC_max(%), P_bc(kW), P_bd(kW)
    P_bc = [0] * 24          # output of battery in charge mode
    P_bd = [0] * 24          # output of battery in discharge mode

    # Enter dummy load capacity(kW)
    P_dummy = [0] * 24
    E_dummy = 0

    # Enter diesel generator capacity(kW), output(kW) and efficiency
    P_dg = [0] * 24

    # NPSP algorithm
    t = 1                             # initial time
    LOLP = [0] * 24                   # initial LOLP at each time
    LOLP_sum = 0
    E_bat = (C_bat * SOC_ini) / 100   # initial kWh capacity of battery at each time
    SOC = [0] * 24                    # initial SOC of battery at each time

    # iteration for day calculation(24h)
    for t in range(24):

        SOC[t] = E_bat / C_bat * 100     # SOC calculation of battery at each time

        if P_wind[t] > P_load[t]: # occurred surplus energy in HRES system
            if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
                P_bc[t] = (P_wind[t] - P_load[t] * Ef_inv + P_pv[t]) * Ef_bc #calculate charge capacity of battery
                E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc         # accumulate capacity of battery
            else:
                P_bc[t] = 0 # calculate charge capacity of battery
                P_dummy[t] = (P_wind[t] - P_load[t]) + P_pv[t] * Ef_inv # calculate capacity of dummy loads to cover surplus energy in HRES system
                E_dummy = E_dummy + P_dummy[t] # accumulate capacity of dummy loads to check total used capacity of dummy loads

        if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) > P_load[t]: # occurred surplus energy in HRES system
            if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
                P_bc[t] = (P_wind[t] + P_pv[t] * Ef_inv - P_load[t]) * Ef_bc * Ef_inv # calculate charge capacity of battery
                E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc # accumulate capacity of battery
            else:
                P_bc[t] = 0  # calculate charge capacity of battery
                P_dummy[t] = P_wind[t] + P_pv[t] * Ef_inv - P_load[t]  # calculate capacity of dummy loads to cover surplus energy in HRES system
                E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

        if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) <= P_load[t]: # occurred deficit energy in HRES system
            if SOC[t] > SOC_min: # check SOC of battery whether the SOC has lack of capacity
                P_bd[t] = (P_pv[t] - (P_load[t] - P_wind[t]) / Ef_inv) * Ef_bd # calculate discharge capacity of battery
                E_bat = E_bat * (1 - r_sd) - abs(P_bd[t]) * Ef_bd # accumulate capacity of battery
            else:
                P_bd[t] = 0 # calculate charge capacity of battery
                P_dg[t] = (P_load[t] - P_wind[t] - P_pv[t] * Ef_inv) / Ef_dg # calculate capacity of diesel generator to cover deficit energy in HRES system
                if P_dg[t] > P_dgr: # check the capacity of diesel generator whether it exceeds rated capacity of diesel generator
                    LOLP[t] = 1 # evaluate LOLP at time t
                    LOLP_sum = LOLP_sum + LOLP[t] # accumulate LOLP at each time
                else:
                    LOLP[t] = 0 # evaluate LOLP at time t

    # check capacity of HRES with constraints of LOLP and dummy loads
    if E_dummy <= 0:
        pass
      # print('Need to increasing capacity of PV or WT.\n')
    else:
        if E_dummy > Con_dummy*DAE:
            pass
          # print('Need to decreasing capacity of PV or WT.\n')
        else:
            if LOLP_sum / t > Con_LOLP:
                pass
              # print('Need to increasing capacity of PV or WT.\n')
            else:
                # print('Present capacities of PV and WT are optimal.\n')
                pass

    return P_wind, P_dummy, P_pv, P_bc, P_bd, P_load, SOC, P_dg, LOLP, LOLP_sum

def get_renewable_energy():

    # 재생 에너지 데이터 불러오기
    weather_df = return_weather_data_by_day()
    electronic_df = return_electronic_data_by_day()
    weather_df['P_load'] = electronic_df['P_load']
    renewable_energy = weather_df
    print(tabulate(renewable_energy, headers='keys', tablefmt='psql'))

    Ef_inv = 0.95
    Con_LOLP = 0.05
    Con_dummy = 0.04
    prompt3 = 1 # 최대 부하량으로 맞추기

    tot_optimal_prompt1 = []
    tot_optimal_prompt2 = []
    tot_optimal_cost = []
    tot_optimal_p_wind = []
    tot_optimal_p_dummy = []
    tot_optimal_p_pv = []
    tot_optimal_p_battery = []
    tot_optimal_p_load = []
    tot_optimal_soc = []
    tot_optimal_p_dg = []
    tot_optimal_lolp = []

    for idx in range(len(renewable_energy)):

        input_p_wind = renewable_energy['P_wind'][idx]
        input_p_pv = renewable_energy['P_pv'][idx]
        input_p_load = renewable_energy['P_load'][idx]

        prompt1_result, prompt2_result, state_result, dummy_result, LOLP_result, P_dg_result, DAE = Optimal_PSO_Algorithm(Ef_inv, Con_LOLP, Con_dummy, prompt3, input_p_wind, input_p_pv, input_p_load)

        cost = []

        # Initial Capital 계산
        for prompt1, prompt2 in zip(prompt1_result, prompt2_result):
            IC = 1.4 * 3000 * prompt2 + 1.2 * 2290 * prompt1 * round(prompt1 / 1) + C_bat * 213 + P_dgr * 850
            cost.append(IC)

        # 태양광(pv) = prompt2, 풍력(wind) = prompt2
        data = {
            'pv(kw)' : prompt2_result,
            'wind(kw)' : prompt1_result,
            'dummy' : dummy_result,
            'LOLP_sum' : LOLP_result,
            'P_dg' : P_dg_result,
            'cost($)' : cost,
            'state' : state_result
        }

        df = pd.DataFrame(data)
        print(tabulate(df, headers='keys', tablefmt='psql'))

        # optimal 값만 찾기
        opt_df = df.loc[df['state'] == '***** Optimal *****', :]
        opt_df = opt_df.sort_values(by='cost($)')
        print(tabulate(opt_df, headers='keys', tablefmt='psql'))

        # optimal 값이 없는 경우
        if opt_df.empty == True:
            # print('최적 발전량 없음')

            optimal_prmt1 = 0
            optimal_prmt2 = 0
            min_cost = 0
            p_wind = None
            p_dummy = None
            p_pv = None
            p_battery = None
            p_load = None
            soc = None
            p_dg = None
            lolp = None

        else:
            opt_prompt1 = opt_df['wind(kw)']
            opt_prompt2 = opt_df['pv(kw)']

            min_prompt1 = 0
            min_prompt2 = 0
            min_cost = 99999999

            # Initial Capital 계산
            for prompt1, prompt2 in zip(opt_prompt1, opt_prompt2):
                IC = 1.4 * 3000 * prompt2 + 1.2 * 2290 * prompt1 * round(prompt1 / 1) + C_bat * 213 + P_dgr * 850
                if min_cost >= IC:
                    min_cost = IC
                    min_prompt1 = prompt1
                    min_prompt2 = prompt2

            optimal_prmt1 = min_prompt1
            optimal_prmt2 = min_prompt2

            P_wind, P_dummy, P_pv, P_bc, P_bd, P_load, SOC, P_dg, LOLP, LOLP_sum \
                = PSO_Algorithm(Ef_inv, Con_LOLP, Con_dummy, optimal_prmt1, optimal_prmt2, prompt3, input_p_wind, input_p_pv, input_p_load)

            # results of optimal values in Function
            p_wind = [round(P_wind[idx], 3) for idx, y in enumerate(P_wind)]
            p_dummy = [round(P_dummy[idx], 3) for idx, y in enumerate(P_dummy)]
            p_pv = [round(P_pv[idx], 3) for idx, y in enumerate(P_pv)]
            p_battery = [round(bc + bd, 3) for bc, bd in zip(P_bc, P_bd)]
            p_load = [round(P_load[idx], 3) for idx, y in enumerate(P_load)]
            soc = [round(SOC[idx], 3) for idx, y in enumerate(SOC)]
            p_dg = [round(P_dg[idx], 3) for idx, y in enumerate(P_dg)]
            lolp = [round(LOLP[idx], 3) for idx, y in enumerate(LOLP)]

        tot_optimal_prompt1.append(optimal_prmt1)
        tot_optimal_prompt2.append(optimal_prmt2)
        tot_optimal_cost.append(min_cost)
        tot_optimal_p_wind.append(p_wind)
        tot_optimal_p_dummy.append(p_dummy)
        tot_optimal_p_pv.append(p_pv)
        tot_optimal_p_battery.append(p_battery)
        tot_optimal_p_load.append(p_load)
        tot_optimal_soc.append(soc)
        tot_optimal_p_dg.append(p_dg)
        tot_optimal_lolp.append(lolp)

    db_data = {
        'Administrative_Area' : renewable_energy['Administrative_Area'],
        'Observation' : renewable_energy['Observation'],
        'P_wind' : renewable_energy['P_wind'],
        'P_pv' : renewable_energy['P_pv'],
        'P_load' : renewable_energy['P_load'],
        'optimal_prompt1' : tot_optimal_prompt1,
        'optimal_prompt2' : tot_optimal_prompt2,
        'optimal_cost' : tot_optimal_cost,
        'optimal_p_wind' : tot_optimal_p_wind,
        'optimal_p_dummy' : tot_optimal_p_dummy,
        'optimal_p_pv' : tot_optimal_p_pv,
        'optimal_p_battery' : tot_optimal_p_battery,
        'optimal_p_load' : tot_optimal_p_load,
        'optimal_soc' : tot_optimal_soc,
        'optimal_p_dg' : tot_optimal_p_dg,
        'optimal_lolp' : tot_optimal_lolp
    }

    df = pd.DataFrame(
        db_data,
        columns=[
            'Administrative_Area',
            'Observation',
            'P_wind',
            'P_pv',
            'P_load',
            'optimal_prompt1',
            'optimal_prompt2',
            'optimal_cost',
            'optimal_p_wind',
            'optimal_p_dummy',
            'optimal_p_pv',
            'optimal_p_battery',
            'optimal_p_load',
            'optimal_soc',
            'optimal_p_dg',
            'optimal_lolp'
        ]
    )
    print(tabulate(df, headers='keys', tablefmt='psql'))

    return df

get_renewable_energy()