from matplotlib import pyplot as plt
import pandas as pd
from tabulate import tabulate
import numpy

def Function1(Ef_inv, Con_LOLP, Con_dummy, prompt3):

    prompt1_result = []
    prompt2_result = []

    for prompt2 in numpy.arange(1, 11, 0.05):
        for prompt1 in numpy.arange(1, 11, 0.05):

            # Types of Power Pattern generated by Wind Turbine during a one day
            P_wind = [0.81, 1.00, 0.57, 0.38, 0.22, 0.35, 0.44, 0.36, 0.57, 0.82, 0.58, 0.33, 0.35, 0.64, 0.64, 0.22,
                      0.18, 0.10, 0.05, 0.08, 0.15, 0.08, 0.14, 0.13]

            # Types of Power Pattern generated by Photovoltaic during a one day
            P_pv = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.2, 0.0,
                    0.0, 0.0, 0.0, 0.0, 0.0]

            # Types of Load Pattern during a one day
            P_load = [0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60,
                      0.53, 0.5, 0.47, 0.45, 0.4, 0.36, 0.34, 0.33]

            # Choice a pattern of wind turbine, Photovoltaic and Load
            P_wind = [round(prompt1 * value, 3) for idx, value in enumerate(P_wind)]
            P_pv = [round(prompt2 * value, 3) for idx, value in enumerate(P_pv)]
            P_load = [round(prompt3 * value, 3) for idx, value in enumerate(P_load)]

            DAE = sum(P_load)

            # Enter battery data, initial SOC(%), SOC_min(%), SOC_max(%), P_bc(kW), P_bd(kW)
            C_bat = 20  # Capacity(kWh)
            SOC_ini = 30  # initial SOC of battery
            SOC_min = 10  # minimum SOC of battery
            SOC_max = 90  # maximum SOC of battery
            P_bc = [0] * 24  # output of battery in charge mode
            P_bd = [0] * 24  # output of battery in discharge mode
            Ef_bc = 0.9  # efficiency of battery in charge mode
            Ef_bd = 0.85  # efficiency of battery in discharge mode
            r_sd = 0.002  # self - discharge rate of battery

            # Enter dummy load capacity(kW)
            P_dummy = [0] * 24
            E_dummy = 0

            # Enter diesel generator capacity(kW), output(kW) and efficiency
            P_dgr = 10
            P_dg = [0] * 24
            Ef_dg = 0.95

            # NPSP algorithm
            t = 1  # initial time
            LOLP = [0] * 24  # initial LOLP at each time
            LOLP_sum = 0
            E_bat = (C_bat * SOC_ini) / 100  # initial kWh capacity of battery at each time
            SOC = [0] * 24  # initial SOC of battery at each time

            # iteration for day calculation(24h)
            for t in range(24):

                SOC[t] = E_bat / C_bat * 100  # SOC calculation of battery at each time

                if P_wind[t] > P_load[t]:  # occurred surplus energy in HRES system
                    if SOC[t] < SOC_max:  # check SOC of battery whether the SOC has enough
                        P_bc[t] = (P_wind[t] - P_load[t] * Ef_inv + P_pv[t]) * Ef_bc  # calculate charge capacity of battery
                        E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc  # accumulate capacity of battery
                    else:
                        P_bc[t] = 0  # calculate charge capacity of battery
                        P_dummy[t] = (P_wind[t] - P_load[t]) + P_pv[t] * Ef_inv  # calculate capacity of dummy loads to cover surplus energy in HRES system
                        E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

                if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) > P_load[
                    t]:  # occurred surplus energy in HRES system
                    if SOC[t] < SOC_max:  # check SOC of battery whether the SOC has enough
                        P_bc[t] = (P_wind[t] + P_pv[t] * Ef_inv - P_load[t]) * Ef_bc * Ef_inv  # calculate charge capacity of battery
                        E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc  # accumulate capacity of battery
                    else:
                        P_bc[t] = 0  # calculate charge capacity of battery
                        P_dummy[t] = P_wind[t] + P_pv[t] * Ef_inv - P_load[t]  # calculate capacity of dummy loads to cover surplus energy in HRES system
                        E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

                if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) <= P_load[
                    t]:  # occurred deficit energy in HRES system
                    if SOC[t] > SOC_min:  # check SOC of battery whether the SOC has lack of capacity
                        P_bd[t] = (P_pv[t] - (P_load[t] - P_wind[t]) / Ef_inv) * Ef_bd  # calculate discharge capacity of battery
                        E_bat = E_bat * (1 - r_sd) - abs(P_bd[t]) * Ef_bd  # accumulate capacity of battery
                    else:
                        P_bd[t] = 0  # calculate charge capacity of battery
                        P_dg[t] = (P_load[t] - P_wind[t] - P_pv[t] * Ef_inv) / Ef_dg  # calculate capacity of diesel generator to cover deficit energy in HRES system
                        if P_dg[t] > P_dgr:  # check the capacity of diesel generator whether it exceeds rated capacity of diesel generator
                            LOLP[t] = 1  # evaluate LOLP at time t
                            LOLP_sum = LOLP_sum + LOLP[t]  # accumulate LOLP at each time
                        else:
                            LOLP[t] = 0  # evaluate LOLP at time t

            # check capacity of HRES with constraints of LOLP and dummy loads
            if E_dummy <= 0:
                pass
                # print('Need to increasing capacity of PV or WT.\n')
            else:
                if E_dummy > Con_dummy * DAE:
                    pass
                    # print('Need to decreasing capacity of PV or WT.\n')
                else:
                    if LOLP_sum / t > Con_LOLP:
                        pass
                        # print('Need to increasing capacity of PV or WT.\n')
                    else:
                        # print('Present capacities of PV and WT are optimal.\n')
                        prompt1_result.append(prompt1)
                        prompt2_result.append(prompt2)

    return prompt1_result, prompt2_result, DAE

def Function2(Ef_inv, Con_LOLP, Con_dummy, prompt1, prompt2, prompt3):

    # Types of Power Pattern generated by Wind Turbine during a one day(1~20)
    P_wind = [0.81, 1.00, 0.57, 0.38, 0.22, 0.35, 0.44, 0.36, 0.57, 0.82, 0.58, 0.33, 0.35, 0.64, 0.64, 0.22, 0.18, 0.10, 0.05, 0.08, 0.15, 0.08, 0.14, 0.13]

    # Types of Power Pattern generated by Photovoltaic during a one day(5~25)
    P_pv = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.2, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]

    # Types of Load Pattern during a one day(5~9)
    P_load = [0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60, 0.53, 0.5, 0.47, 0.45, 0.4, 0.36, 0.34, 0.33]

    # Choice a pattern of wind turbine, Photovoltaic and Load
    P_wind = [round(prompt1 * value, 3) for idx, value in enumerate(P_wind)]
    P_pv = [round(prompt2 * value, 3) for idx, value in enumerate(P_pv)]
    P_load = [round(prompt3 * value, 3) for idx, value in enumerate(P_load)]

    DAE = sum(P_load)

    # Enter battery data, initial SOC(%), SOC_min(%), SOC_max(%), P_bc(kW), P_bd(kW)
    C_bat = 20            # Capacity(kWh)
    SOC_ini = 30         # initial SOC of battery
    SOC_min = 10         # minimum SOC of battery
    SOC_max = 90         # maximum SOC of battery
    P_bc = [0] * 24          # output of battery in charge mode
    P_bd = [0] * 24          # output of battery in discharge mode
    Ef_bc = 0.9             # efficiency of battery in charge mode
    Ef_bd = 0.85         # efficiency of battery in discharge mode
    r_sd = 0.002         # self - discharge rate of battery

    # Enter dummy load capacity(kW)
    P_dummy = [0] * 24
    E_dummy = 0

    # Enter diesel generator capacity(kW), output(kW) and efficiency
    P_dgr = 10
    P_dg = [0] * 24
    Ef_dg = 0.95

    # NPSP algorithm
    t = 1                     # initial time
    LOLP = [0] * 24               # initial LOLP at each time
    LOLP_sum = 0
    E_bat = (C_bat * SOC_ini) / 100   # initial kWh capacity of battery at each time
    SOC = [0] * 24               # initial SOC of battery at each time

    # iteration for day calculation(24h)
    for t in range(24):

        SOC[t] = E_bat / C_bat * 100     # SOC calculation of battery at each time

        if P_wind[t] > P_load[t]: # occurred surplus energy in HRES system
            if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
                P_bc[t] = (P_wind[t] - P_load[t] * Ef_inv + P_pv[t]) * Ef_bc #calculate charge capacity of battery
                E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc         # accumulate capacity of battery
            else:
                P_bc[t] = 0 # calculate charge capacity of battery
                P_dummy[t] = (P_wind[t] - P_load[t]) + P_pv[t] * Ef_inv # calculate capacity of dummy loads to cover surplus energy in HRES system
                E_dummy = E_dummy + P_dummy[t] # accumulate capacity of dummy loads to check total used capacity of dummy loads

        if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) > P_load[t]: # occurred surplus energy in HRES system
            if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
                P_bc[t] = (P_wind[t] + P_pv[t] * Ef_inv - P_load[t]) * Ef_bc * Ef_inv # calculate charge capacity of battery
                E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc # accumulate capacity of battery
            else:
                P_bc[t] = 0  # calculate charge capacity of battery
                P_dummy[t] = P_wind[t] + P_pv[t] * Ef_inv - P_load[t]  # calculate capacity of dummy loads to cover surplus energy in HRES system
                E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

        if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) <= P_load[t]: # occurred deficit energy in HRES system
            if SOC[t] > SOC_min: # check SOC of battery whether the SOC has lack of capacity
                P_bd[t] = (P_pv[t] - (P_load[t] - P_wind[t]) / Ef_inv) * Ef_bd # calculate discharge capacity of battery
                E_bat = E_bat * (1 - r_sd) - abs(P_bd[t]) * Ef_bd # accumulate capacity of battery
            else:
                P_bd[t] = 0 # calculate charge capacity of battery
                P_dg[t] = (P_load[t] - P_wind[t] - P_pv[t] * Ef_inv) / Ef_dg # calculate capacity of diesel generator to cover deficit energy in HRES system
                if P_dg[t] > P_dgr: # check the capacity of diesel generator whether it exceeds rated capacity of diesel generator
                    LOLP[t] = 1 # evaluate LOLP at time t
                    LOLP_sum = LOLP_sum + LOLP[t] # accumulate LOLP at each time
                else:
                    LOLP[t] = 0 # evaluate LOLP at time t

    # check capacity of HRES with constraints of LOLP and dummy loads
    if E_dummy <= 0:
        pass
      # print('Need to increasing capacity of PV or WT.\n')
    else:
        if E_dummy > Con_dummy * DAE:
            pass
          # print('Need to decreasing capacity of PV or WT.\n')
        else:
            if LOLP_sum / t > Con_LOLP:
                pass
              # print('Need to increasing capacity of PV or WT.\n')
            else:
                # print('Present capacities of PV and WT are optimal.\n')
                pass

    return P_wind, P_dummy, P_pv, P_bc, P_bd, P_load, SOC, P_dg

# input a efficiency of inverter, constraints of LOLP, constraints ofdummy
print('Enter the efficiency of inverter: ')
Ef_inv = float(input())
print('Enter the constraints of LOLP: ')
Con_LOLP = float(input())
print('Enter the constraints of dummy: ')
Con_dummy = float(input())
print('choice a Types of Load PatternP_load: ')
prompt3 = int(input()) # prompt3는 1~5까지(P_load 값만 사용자가 입력)

prompt1_result = []
prompt2_result = []

prompt1_result, prompt2_result, DAE = Function1(Ef_inv, Con_LOLP, Con_dummy, prompt3)

cost = []
min_prompt1 = 0
min_prompt2 = 0
min_cost = 99999999

# Initial Capital 계산
for prompt1, prompt2 in zip(prompt1_result, prompt2_result):
    IC = 1.4 * 3000 * prompt1 + 1.2 * 2290 * prompt2 * round(prompt2 / 1)
    if min_cost >= IC:
        min_cost = IC
        min_prompt1 = prompt1
        min_prompt2 = prompt2

    cost.append(IC)

# 태양광(pv) = prompt2, 풍력(wind) = prompt1
data = {
    'pv(kw)' : prompt2_result,
    'wind(kw)' : prompt1_result,
    'cost($)' : cost
}

df = pd.DataFrame(data)

print(tabulate(df, headers='keys', tablefmt='psql'))

optimal_prompt1 = min_prompt1
optimal_prompt2 = min_prompt2

P_wind, P_dummy, P_pv, P_bc, P_bd, P_load, SOC, P_dg = Function2(Ef_inv, Con_LOLP, Con_dummy, optimal_prompt1, optimal_prompt2, prompt3)

print(P_dg)

# ploting the simulation results
# P_wind 그래프
plt.subplot(4, 2, 1)
x_pos = [x for x in range(24)]
y_pos1 = [round(P_wind[idx], 3) for idx, y in enumerate(P_wind)]
plt.plot(x_pos, y_pos1)
plt.xlabel('t(h)')
plt.ylabel('Power of Wind Turbine(kWh)')

# P_dummy 그래프
plt.subplot(4, 2, 2)
y_pos2 = [round(P_dummy[idx], 3) for idx, y in enumerate(P_dummy)]
plt.plot(x_pos, y_pos2)
plt.xlabel('t(h)')
plt.ylabel('Power of Dummy(kWh)')

# P_pv 그래프
plt.subplot(4, 2, 3)
y_pos3 = [round(P_pv[idx], 3) for idx, y in enumerate(P_pv)]
plt.plot(x_pos, y_pos3)
plt.xlabel('t(h)')
plt.ylabel('Power of Photovoltaic(kWh)')

# Pbat 그래프
plt.subplot(4, 2, 4)
y_pos4 = [round(bc + bd, 3) for bc, bd in zip(P_bc, P_bd)]
plt.plot(x_pos, y_pos4)
plt.xlabel('t(h)')
plt.ylabel('Power of Battery(kWh)')

# P_load 그래프
plt.subplot(4, 2, 5)
y_pos5 = [round(P_load[idx], 3) for idx, y in enumerate(P_load)]
plt.plot(x_pos, y_pos5)
plt.xlabel('t(h)')
plt.ylabel('Power of Load(kWh)')

# SOC 그래프
plt.subplot(4, 2, 6)
y_pos6 = [round(SOC[idx], 3) for idx, y in enumerate(SOC)]
plt.plot(x_pos, y_pos6)
plt.xlabel('t(h)')
plt.ylabel('SOC(%)')

# P_dg 그래프
plt.subplot(4, 2, 7)
y_pos7 = [round(P_dg[idx], 3) for idx, y in enumerate(P_dg)]
plt.plot(x_pos, y_pos7)
plt.xlabel('t(h)')
plt.ylabel('Power of DG(kWh)')

# 그래프
plt.subplot(4, 2, 8)
y_pos8 = [y for y in range(24)]
plt.plot(x_pos, y_pos8)
plt.xlabel('')
plt.ylabel('')

plt.show()