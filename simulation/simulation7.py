import numpy as np
from matplotlib import pyplot as plt
from matplotlib import ticker as ticker
import pandas as pd
from tabulate import tabulate

# 설정 초기 상수
C_bat = 20  # Capacity(kWh)
SOC_ini = 30  # initial SOC of battery
SOC_min = 10  # minimum SOC of battery
SOC_max = 90  # maximum SOC of battery

Ef_bc = 0.9  # efficiency of battery in charge mode
Ef_bd = 0.85  # efficiency of battery in discharge mode
r_sd = 0.002  # self - discharge rate of battery

P_dgr = 10
Ef_dg = 0.95

def Function1(Ef_inv, Con_LOLP, Con_dummy, prompt3, want_iteration):

    prompt1_result = []
    prompt2_result = []
    dummy_result = []
    LOLP_result = []
    P_dg_result = []
    state_result = []

    # noinspection PyTypeChecke
    for prompt2 in np.arange(1, want_iteration, 1):
        for prompt1 in np.arange(1, want_iteration, 1):

            # Types of Power Pattern generated by Wind Turbine during a one day
            u = [7.15, 12, 12, 12, 12, 11.64, 11.46, 6.53, 12, 9.87, 12, 12, 12, 10.69, 12, 10.69, 9.21, 9.66, 6.85,
                 8.74, 9.66, 5.48, 7.15, 7.72]

            Pw_wind = [0] * 24

            uc = 3   # 최소 발전가능한 풍속 제한 [m/s]
            uf = 25  # 최대 발전가능한 풍속 제한 [m/s]
            ur = 12  # 정격 풍속 [m/s]

            for t in range(24):
                if (u[t] < uc) or (u[t] > uf):
                    Pw_wind[t] = 0  # WT 출력 [MW]
                else:
                    if uc <= u[t] <= ur:
                        Pw_wind[t] = round((u[t] * u[t] - uc * uc) / (ur * ur - uc * uc), 4)  # WT 출력 [MW]
                    else:
                        if ur <= u[t] <= uf:
                            Pw_wind[t] = 1  # WT 출력 [MW]
                            print(Pw_wind)

            P_wind = Pw_wind

            # Types of Power Pattern generated by Photovoltaic during a one day
            P_pv = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.2, 0.0,
                    0.0, 0.0, 0.0, 0.0, 0.0]

            # Types of Load Pattern during a one day
            P_load = [0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60,
                      0.53, 0.5, 0.47, 0.45, 0.4, 0.36, 0.34, 0.33]

            # Choice a pattern of wind turbine, Photovoltaic and Load
            P_wind = [round(prompt1 * value, 3) for idx, value in enumerate(P_wind)]
            P_pv = [round(prompt2 * value, 3) for idx, value in enumerate(P_pv)]
            P_load = [round(prompt3 * value, 3) for idx, value in enumerate(P_load)]

            DAE = sum(P_load)

            # Enter battery data, initial SOC(%), SOC_min(%), SOC_max(%), P_bc(kW), P_bd(kW)
            P_bc = [0] * 24  # output of battery in charge mode
            P_bd = [0] * 24  # output of battery in discharge mode

            # Enter dummy load capacity(kW)
            P_dummy = [0] * 24
            E_dummy = 0

            # Enter diesel generator capacity(kW), output(kW) and efficiency
            P_dg = [0] * 24

            # NPSP algorithm
            t = 1  # initial time
            LOLP = [0] * 24  # initial LOLP at each time
            LOLP_sum = 0
            E_bat = (C_bat * SOC_ini) / 100  # initial kWh capacity of battery at each time
            SOC = [0] * 24  # initial SOC of battery at each time

            # iteration for day calculation(24h)
            for t in range(24):

                SOC[t] = E_bat / C_bat * 100  # SOC calculation of battery at each time

                if P_wind[t] > P_load[t]:  # occurred surplus energy in HRES system
                    if SOC[t] < SOC_max:  # check SOC of battery whether the SOC has enough
                        P_bc[t] = (P_wind[t] - P_load[t] * Ef_inv + P_pv[t]) * Ef_bc  # calculate charge capacity of battery
                        E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc  # accumulate capacity of battery
                    else:
                        P_bc[t] = 0  # calculate charge capacity of battery
                        P_dummy[t] = (P_wind[t] - P_load[t]) + P_pv[t] * Ef_inv  # calculate capacity of dummy loads to cover surplus energy in HRES system
                        E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

                if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) > P_load[t]:  # occurred surplus energy in HRES system
                    if SOC[t] < SOC_max:  # check SOC of battery whether the SOC has enough
                        P_bc[t] = (P_wind[t] + P_pv[t] * Ef_inv - P_load[t]) * Ef_bc * Ef_inv  # calculate charge capacity of battery
                        E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc  # accumulate capacity of battery
                    else:
                        P_bc[t] = 0  # calculate charge capacity of battery
                        P_dummy[t] = P_wind[t] + P_pv[t] * Ef_inv - P_load[t]  # calculate capacity of dummy loads to cover surplus energy in HRES system
                        E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

                if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) <= P_load[t]:  # occurred deficit energy in HRES system
                    if SOC[t] > SOC_min:  # check SOC of battery whether the SOC has lack of capacity
                        P_bd[t] = (P_pv[t] - (P_load[t] - P_wind[t]) / Ef_inv) * Ef_bd  # calculate discharge capacity of battery
                        E_bat = E_bat * (1 - r_sd) - abs(P_bd[t]) * Ef_bd  # accumulate capacity of battery
                    else:
                        P_bd[t] = 0  # calculate charge capacity of battery
                        P_dg[t] = (P_load[t] - P_wind[t] - P_pv[t] * Ef_inv) / Ef_dg  # calculate capacity of diesel generator to cover deficit energy in HRES system
                        if P_dg[t] > P_dgr:  # check the capacity of diesel generator whether it exceeds rated capacity of diesel generator
                            LOLP[t] = 1  # evaluate LOLP at time t
                            LOLP_sum = LOLP_sum + LOLP[t]  # accumulate LOLP at each time
                        else:
                            LOLP[t] = 0  # evaluate LOLP at time t

            # check capacity of HRES with constraints of LOLP and dummy loads
            if E_dummy <= 0:
                state = 'Increasing'
                pass
               #print('Need to increasing capacity of PV or WT.\n')
            else:
                if E_dummy > Con_dummy*DAE:
                    state = 'Decreasing'
                    pass
                    #print('Need to decreasing capacity of PV or WT.\n')
                else:
                    if LOLP_sum / t > Con_LOLP:
                        state = 'Increasing'
                        pass
                        #print('Need to increasing capacity of PV or WT.\n')
                    else:
                        state = '***** Optimal *****'
                        # print('Present capacities of PV and WT are optimal.\n')

            dummy_sum = sum(P_dummy)
            P_dg_sum = sum(P_dg)

            print(LOLP_sum)

            state_result.append(state)
            prompt1_result.append(prompt1)
            prompt2_result.append(prompt2)
            dummy_result.append(dummy_sum)
            LOLP_result.append(sum(LOLP))
            P_dg_result.append(P_dg_sum)

    return prompt1_result, prompt2_result, state_result, dummy_result, LOLP_result, P_dg_result, DAE

def Function2(Ef_inv, Con_LOLP, Con_dummy, prompt1, prompt2, prompt3):

    # Types of Power Pattern generated by Wind Turbine during a one day
    u = [7.15, 12, 12, 12, 12, 11.64, 11.46, 6.53, 12, 9.87, 12, 12, 12, 10.69, 12, 10.69, 9.21, 9.66, 6.85,
         8.74, 9.66, 5.48, 7.15, 7.72]

    Pw_wind = [0] * 24

    uc = 3  # 최소 발전가능한 풍속 제한 [m/s]
    uf = 25  # 최대 발전가능한 풍속 제한 [m/s]
    ur = 12  # 정격 풍속 [m/s]

    for t in range(24):
        if (u[t] < uc) or (u[t] > uf):
            Pw_wind[t] = 0  # WT 출력 [MW]
        else:
            if uc <= u[t] <= ur:
                Pw_wind[t] = round((u[t] * u[t] - uc * uc) / (ur * ur - uc * uc), 4)  # WT 출력 [MW]
            else:
                if ur <= u[t] <= uf:
                    Pw_wind[t] = 1  # WT 출력 [MW]
                    print(Pw_wind)

    P_wind = Pw_wind

    # Types of Power Pattern generated by Photovoltaic during a one day(5~25)
    P_pv = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.2, 0.5, 0.7, 0.9, 1.0, 0.9, 0.8, 0.7, 0.53125, 0.2, 0.0, 0.0,
            0.0, 0.0, 0.0, 0.0]

    # Types of Load Pattern during a one day(5~9)
    P_load = [0.33, 0.32, 0.32, 0.31, 0.30, 0.30, 0.34, 0.40, 0.50, 0.70, 0.69, 0.60, 0.55, 0.70, 0.68, 0.60, 0.53,
              0.5, 0.47, 0.45, 0.4, 0.36, 0.34, 0.33]

    # Choice a pattern of wind turbine, Photovoltaic and Load
    P_wind = [round(prompt1 * value, 3) for idx, value in enumerate(P_wind)]
    P_pv = [round(prompt2 * value, 3) for idx, value in enumerate(P_pv)]
    P_load = [round(prompt3 * value, 3) for idx, value in enumerate(P_load)]

    DAE = sum(P_load)

    # Enter battery data, initial SOC(%), SOC_min(%), SOC_max(%), P_bc(kW), P_bd(kW)
    P_bc = [0] * 24          # output of battery in charge mode
    P_bd = [0] * 24          # output of battery in discharge mode

    # Enter dummy load capacity(kW)
    P_dummy = [0] * 24
    E_dummy = 0

    # Enter diesel generator capacity(kW), output(kW) and efficiency
    P_dg = [0] * 24

    # NPSP algorithm
    t = 1                             # initial time
    LOLP = [0] * 24                   # initial LOLP at each time
    LOLP_sum = 0
    E_bat = (C_bat * SOC_ini) / 100   # initial kWh capacity of battery at each time
    SOC = [0] * 24                    # initial SOC of battery at each time

    # iteration for day calculation(24h)
    for t in range(24):

        SOC[t] = E_bat / C_bat * 100     # SOC calculation of battery at each time

        if P_wind[t] > P_load[t]: # occurred surplus energy in HRES system
            if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
                P_bc[t] = (P_wind[t] - P_load[t] * Ef_inv + P_pv[t]) * Ef_bc #calculate charge capacity of battery
                E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc         # accumulate capacity of battery
            else:
                P_bc[t] = 0 # calculate charge capacity of battery
                P_dummy[t] = (P_wind[t] - P_load[t]) + P_pv[t] * Ef_inv # calculate capacity of dummy loads to cover surplus energy in HRES system
                E_dummy = E_dummy + P_dummy[t] # accumulate capacity of dummy loads to check total used capacity of dummy loads

        if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) > P_load[t]: # occurred surplus energy in HRES system
            if SOC[t] < SOC_max: # check SOC of battery whether the SOC has enough
                P_bc[t] = (P_wind[t] + P_pv[t] * Ef_inv - P_load[t]) * Ef_bc * Ef_inv # calculate charge capacity of battery
                E_bat = E_bat * (1 - r_sd) + P_bc[t] * Ef_bc # accumulate capacity of battery
            else:
                P_bc[t] = 0  # calculate charge capacity of battery
                P_dummy[t] = P_wind[t] + P_pv[t] * Ef_inv - P_load[t]  # calculate capacity of dummy loads to cover surplus energy in HRES system
                E_dummy = E_dummy + P_dummy[t]  # accumulate capacity of dummy loads to check total used capacity of dummy loads

        if P_wind[t] <= P_load[t] and (P_wind[t] + P_pv[t] * Ef_inv) <= P_load[t]: # occurred deficit energy in HRES system
            if SOC[t] > SOC_min: # check SOC of battery whether the SOC has lack of capacity
                P_bd[t] = (P_pv[t] - (P_load[t] - P_wind[t]) / Ef_inv) * Ef_bd # calculate discharge capacity of battery
                E_bat = E_bat * (1 - r_sd) - abs(P_bd[t]) * Ef_bd # accumulate capacity of battery
            else:
                P_bd[t] = 0 # calculate charge capacity of battery
                P_dg[t] = (P_load[t] - P_wind[t] - P_pv[t] * Ef_inv) / Ef_dg # calculate capacity of diesel generator to cover deficit energy in HRES system
                if P_dg[t] > P_dgr: # check the capacity of diesel generator whether it exceeds rated capacity of diesel generator
                    LOLP[t] = 1 # evaluate LOLP at time t
                    LOLP_sum = LOLP_sum + LOLP[t] # accumulate LOLP at each time
                else:
                    LOLP[t] = 0 # evaluate LOLP at time t

    # check capacity of HRES with constraints of LOLP and dummy loads
    if E_dummy <= 0:
        pass
      # print('Need to increasing capacity of PV or WT.\n')
    else:
        if E_dummy > Con_dummy*DAE:
            pass
          # print('Need to decreasing capacity of PV or WT.\n')
        else:
            if LOLP_sum / t > Con_LOLP:
                pass
              # print('Need to increasing capacity of PV or WT.\n')
            else:
                # print('Present capacities of PV and WT are optimal.\n')
                pass

    return P_wind, P_dummy, P_pv, P_bc, P_bd, P_load, SOC, P_dg, LOLP, LOLP_sum

# def make_excel(y_pos1, y_pos2, y_pos3, y_pos4, y_pos5, y_pos6):
#     # 엑셀 파일 저장 위치
#     excel_file_path = 'C:/Users/battl/PycharmProjects/ComputerScienceEngineering/project list/Optimum Capacity Design of Renewable Energy Source Project/excel/'
#     # 엑셀 파일 이름
#     excel_file_name = excel_file_path + 'simulation.xlsx'
#     # 엑셀 sheet 이름
#     excel_sheet_title = '1'
#
#     work_book = Workbook()
#     sheet1 = work_book.active
#     sheet1.title = excel_sheet_title
#
#     # 헤더 입력
#     sheet1.cell(row=1, column=1).value = 'Pwt'
#     sheet1.cell(row=1, column=2).value = 'Pdummy'
#     sheet1.cell(row=1, column=3).value = 'Ppv'
#     sheet1.cell(row=1, column=4).value = 'Pbat'
#     sheet1.cell(row=1, column=5).value = 'Pload'
#     sheet1.cell(row=1, column=6).value = 'SOC'
#
#     # 엑셀 행, 열
#     excel_row = 2
#     excel_column = 1
#     for idx, values in enumerate(y_pos1):
#         sheet1.cell(row=excel_row, column=excel_column).value = values
#         excel_row += 1
#
#     # 엑셀 행, 열
#     excel_row = 2
#     excel_column = 2
#     for idx, values in enumerate(y_pos2):
#         sheet1.cell(row=excel_row, column=excel_column).value = values
#         excel_row += 1
#
#     # 엑셀 행, 열
#     excel_row = 2
#     excel_column = 3
#     for idx, values in enumerate(y_pos3):
#         sheet1.cell(row=excel_row, column=excel_column).value = values
#         excel_row += 1
#
#     # 엑셀 행, 열
#     excel_row = 2
#     excel_column = 4
#     for idx, values in enumerate(y_pos4):
#         sheet1.cell(row=excel_row, column=excel_column).value = values
#         excel_row += 1
#
#     # 엑셀 행, 열
#     excel_row = 2
#     excel_column = 5
#     for idx, values in enumerate(y_pos5):
#         sheet1.cell(row=excel_row, column=excel_column).value = values
#         excel_row += 1
#
#     # 엑셀 행, 열
#     excel_row = 2
#     excel_column = 6
#     for idx, values in enumerate(y_pos6):
#         sheet1.cell(row=excel_row, column=excel_column).value = values
#         excel_row += 1
#
#     # 엑셀 파일 크기 조정하기
#     work_book.save(filename=excel_file_name)
#     work_book.close()

def main():
    # input a efficiency of inverter, constraints of LOLP, constraints ofdummy
    Ef_inv = float(input('Enter the efficiency of inverter: '))
    Con_LOLP = float(input('Enter the constraints of LOLP: '))
    Con_dummy = float(input('Enter the constraints of dummy: '))
    prompt3 = int(input('choice a Types of Load PatternP_load: ')) # prompt3는 1~5까지(P_load 값만 사용자가 입력)
    want_iteration = int(input('input want iteration: '))

    want_prompt1 = int(input('input want prompt1(wind) iteration number(< want_iteration): '))
    want_prompt2 = int(input('input want prompt2(pv) iteration number(< want_iteration): '))

    prompt1_result = []
    prompt2_result = []
    state_result = []
    dummy_result = []
    LOLP_result = []

    prompt1_result, prompt2_result, state_result, dummy_result, LOLP_result, P_dg_result, DAE = Function1(Ef_inv, Con_LOLP, Con_dummy, prompt3, want_iteration)

    cost = []

    # Initial Capital 계산
    for prompt1, prompt2 in zip(prompt1_result, prompt2_result):
        IC = 1.4 * 3000 * prompt2 + 1.2 * 2290 * prompt1 * round(prompt1 / 1) + C_bat * 213 + P_dgr * 850
        cost.append(IC)

    # 태양광(pv) = prompt2, 풍력(wind) = prompt2
    data = {
        'pv(kw)' : prompt2_result,
        'wind(kw)' : prompt1_result,
        'dummy' : dummy_result,
        'LOLP_sum' : LOLP_result,
        'P_dg' : P_dg_result,
        'cost($)' : cost,
        'state' : state_result
    }

    df = pd.DataFrame(data)
    print(tabulate(df, headers='keys', tablefmt='psql'))

    opt_df = df.loc[df['state'] == '***** Optimal *****', :]
    opt_df = opt_df.sort_values(by='cost($)')
    print(tabulate(opt_df, headers='keys', tablefmt='psql'))

    opt_prompt1 = opt_df['wind(kw)']
    opt_prompt2 = opt_df['pv(kw)']

    min_prompt1 = 0
    min_prompt2 = 0
    min_cost = 99999999

    # Initial Capital 계산
    for prompt1, prompt2 in zip(opt_prompt1, opt_prompt2):
        IC = 1.4 * 3000 * prompt2 + 1.2 * 2290 * prompt1 * round(prompt1 / 1) + C_bat * 213 + P_dgr * 850
        if min_cost >= IC:
            min_cost = IC
            min_prompt1 = prompt1
            min_prompt2 = prompt2

    optimal_prompt1 = min_prompt1
    optimal_prompt2 = min_prompt2

    P_wind, P_dummy, P_pv, P_bc, P_bd, P_load, SOC, P_dg, LOLP, LOLP_sum = Function2(Ef_inv, Con_LOLP, Con_dummy, optimal_prompt1, optimal_prompt2, prompt3)

    want_P_wind, want_P_dummy, want_P_pv, want_P_bc, want_P_bd, want_P_load, want_SOC, want_P_dg, want_LOLP, want_LOLP_sum = Function2(Ef_inv, Con_LOLP, Con_dummy, want_prompt1, want_prompt2, prompt3)

    # save excel file
    # make_excel(y_pos1, y_pos2, y_pos3, y_pos4, y_pos5, y_pos6)

    # ploting the simulation results
    x_pos = [x for x in range(24)]
    y_pos1 = [round(P_wind[idx], 3) for idx, y in enumerate(P_wind)]
    y_pos2 = [round(P_dummy[idx], 3) for idx, y in enumerate(P_dummy)]
    y_pos3 = [round(P_pv[idx], 3) for idx, y in enumerate(P_pv)]
    y_pos4 = [round(bc + bd, 3) for bc, bd in zip(P_bc, P_bd)]
    y_pos5 = [round(P_load[idx], 3) for idx, y in enumerate(P_load)]
    y_pos6 = [round(SOC[idx], 3) for idx, y in enumerate(SOC)]
    y_pos7 = [round(P_dg[idx], 3) for idx, y in enumerate(P_dg)]
    y_pos8 = [round(LOLP[idx], 3) for idx, y in enumerate(LOLP)]

    y_pos9 = [round(want_P_wind[idx], 3) for idx, y in enumerate(want_P_wind)]
    y_pos10 = [round(want_P_dummy[idx], 3) for idx, y in enumerate(want_P_dummy)]
    y_pos11 = [round(want_P_pv[idx], 3) for idx, y in enumerate(want_P_pv)]
    y_pos12 = [round(bc + bd, 3) for bc, bd in zip(want_P_bc, want_P_bd)]
    y_pos13 = [round(want_P_load[idx], 3) for idx, y in enumerate(want_P_load)]
    y_pos14 = [round(want_SOC[idx], 3) for idx, y in enumerate(want_SOC)]
    y_pos15 = [round(want_P_dg[idx], 3) for idx, y in enumerate(want_P_dg)]
    y_pos16 = [round(want_LOLP[idx], 3) for idx, y in enumerate(want_LOLP)]


    fig1 = plt.figure()

    # P_wind 그래프
    ax1 = fig1.add_subplot(4, 2, 1)
    ax1.plot(x_pos, y_pos1, label='P_wind', c='b', ls='--')
    ax1.xaxis.set_ticks(np.arange(0, 24, 2))
    ax1.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax1.set_xlabel('t(h)')
    # ax1.set_ylabel('Power of Wind Turbine(kWh)')
    plt.legend(loc='best')

    # P_dummy 그래프
    ax2 = fig1.add_subplot(4, 2, 2)
    ax2.plot(x_pos, y_pos2, label='Dummy', c='g', ls='--')
    ax2.xaxis.set_ticks(np.arange(0, 24, 2))
    ax2.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax2.set_xlabel('t(h)')
    # ax2.set_ylabel('Power of Dummy(kWh)')
    plt.legend(loc='best')

    # P_pv 그래프
    ax3 = fig1.add_subplot(4, 2, 3)
    ax3.plot(x_pos, y_pos3, label='P_pv', c='r', ls='--')
    ax3.xaxis.set_ticks(np.arange(0, 24, 2))
    ax3.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax3.set_xlabel('t(h)')
    # ax3.set_ylabel('Power of Photovoltaic(kWh)')
    plt.legend(loc='best')

    # Pbat 그래프
    ax4 = fig1.add_subplot(4, 2, 4)
    ax4.plot(x_pos, y_pos4, label='Pbat', c='c', ls='--')
    ax4.xaxis.set_ticks(np.arange(0, 24, 2))
    ax4.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax4.set_xlabel('t(h)')
    # ax4.set_ylabel('Power of Battery(kWh)')
    plt.legend(loc='best')

    # P_load 그래프
    ax5 = fig1.add_subplot(4, 2, 5)
    ax5.plot(x_pos, y_pos5, label='P_load', c='m', ls='--')
    ax5.xaxis.set_ticks(np.arange(0, 24, 2))
    ax5.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax5.set_xlabel('t(h)')
    # ax5.set_ylabel('Power of Load(kWh)')
    plt.legend(loc='best')

    # SOC 그래프
    ax6 = fig1.add_subplot(4, 2, 6)
    ax6.plot(x_pos, y_pos6, label='SOC', c='y', ls='--')
    ax6.xaxis.set_ticks(np.arange(0, 24, 2))
    ax6.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax6.set_xlabel('t(h)')
    # ax6.set_ylabel('SOC(%)')
    plt.legend(loc='best')

    # P_dg 그래프
    ax7 = fig1.add_subplot(4, 2, 7)
    ax7.plot(x_pos, y_pos7, label='P_dg', c='k', ls='--')
    ax7.xaxis.set_ticks(np.arange(0, 24, 2))
    ax7.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax7.set_xlabel('t(h)')
    # ax7.set_ylabel('Power of DG(kWh)')
    plt.legend(loc='best')

    # LOLP 그래프
    ax8 = fig1.add_subplot(4, 2, 8)
    ax8.plot(x_pos, y_pos8, label='LOLP', c='tomato', ls='--')
    ax8.xaxis.set_ticks(np.arange(0, 24, 2))
    ax8.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax8.set_xlabel('t(h)')
    # ax8.set_ylabel('Number of LOLP')
    plt.legend(loc='best')






    fig2 = plt.figure(2)

    # P_wind 그래프
    ax9 = fig2.add_subplot(4, 2, 1)
    ax9.plot(x_pos, y_pos9, label='P_wind', c='b', ls='--')
    ax9.xaxis.set_ticks(np.arange(0, 24, 2))
    ax9.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax9.set_xlabel('t(h)')
    # ax9.set_ylabel('Power of Wind Turbine(kWh)')
    plt.legend(loc='best')

    # P_dummy 그래프
    ax10 = fig2.add_subplot(4, 2, 2)
    ax10.plot(x_pos, y_pos10, label='Dummy', c='g', ls='--')
    ax10.xaxis.set_ticks(np.arange(0, 24, 2))
    ax10.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax10.set_xlabel('t(h)')
    # ax10.set_ylabel('Power of Dummy(kWh)')
    plt.legend(loc='best')

    # P_pv 그래프
    ax11 = fig2.add_subplot(4, 2, 3)
    ax11.plot(x_pos, y_pos11, label='P_pv', c='r', ls='--')
    ax11.xaxis.set_ticks(np.arange(0, 24, 2))
    ax11.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax11.set_xlabel('t(h)')
    # ax11.set_ylabel('Power of Photovoltaic(kWh)')
    plt.legend(loc='best')

    # Pbat 그래프
    ax12 = fig2.add_subplot(4, 2, 4)
    ax12.plot(x_pos, y_pos12, label='Pbat', c='c', ls='--')
    ax12.xaxis.set_ticks(np.arange(0, 24, 2))
    ax12.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax12.set_xlabel('t(h)')
    # ax12.set_ylabel('Power of Battery(kWh)')
    plt.legend(loc='best')

    # P_load 그래프
    ax13 = fig2.add_subplot(4, 2, 5)
    ax13.plot(x_pos, y_pos13, label='P_load', c='m', ls='--')
    ax13.xaxis.set_ticks(np.arange(0, 24, 2))
    ax13.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax13.set_xlabel('t(h)')
    # ax13.set_ylabel('Power of Load(kWh)')
    plt.legend(loc='best')

    # SOC 그래프
    ax14 = fig2.add_subplot(4, 2, 6)
    ax14.plot(x_pos, y_pos14, label='SOC', c='y', ls='--')
    ax14.xaxis.set_ticks(np.arange(0, 24, 2))
    ax14.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax14.set_xlabel('t(h)')
    # ax14.set_ylabel('SOC(%)')
    plt.legend(loc='best')

    # P_dg 그래프
    ax15 = fig2.add_subplot(4, 2, 7)
    ax15.plot(x_pos, y_pos15, label='P_dg', c='k', ls='--')
    ax15.xaxis.set_ticks(np.arange(0, 24, 2))
    ax15.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax15.set_xlabel('t(h)')
    # ax15.set_ylabel('Power of DG(kWh)')
    plt.legend(loc='best')

    # LOLP 그래프
    ax16 = fig2.add_subplot(4, 2, 8)
    ax16.plot(x_pos, y_pos16, label='LOLP', c='tomato', ls='--')
    ax16.xaxis.set_ticks(np.arange(0, 24, 2))
    ax16.xaxis.set_major_formatter(ticker.FormatStrFormatter('%d'))
    # ax16.set_xlabel('t(h)')
    # ax16.set_ylabel('Number of LOLP')
    plt.legend(loc='best')

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    main()